# SimulationApp
An application project for a proof of concept algorithm development use case.  This repo relies on content from the following repositories to support the demonstration:
- Algo_Cluster_Infrastructure:  Instructions and Ansible playbooks to setup Rancher Kubernetes cluster.
- Algo_Dev_Scenario_1:  A scenario repository containing base runtime (OpenJDK) and execution data.
- Algo_Dev_Scenario_2:  Another scenario repository containing base runtime (OpenJDK) and execution data.

## Algorithm Development in a DevSecOps Software Factory
The primary objective of this project is to demonstrate one approach to tailoring and applying DevSecOps practices within our domain.  The use case we're exploring is algorithm development.  In the past, we often see algorithm reference implementations created in a "heavy math" environment using simulations and monte-carlo analysis to evaluate changes and assess performance.  It is very common to see heavy Matlab use in this context which is almost always executed as a single threaded monolithic application.  The evaluation scenarios can often run for a very long time, sometimes days or weeks.  Here we want to explore
applying DoD CIO DevSecOps Reference Design guidance to this use case.  To that end, we're going to build pipelines to automate the build and packaging of our algorithm into a container.  We will then run that container within a Kubernetes environment.  Most commercial use cases for Kubernetes are focused on availability and scaling.  In this instance, we need to focus on job execution and load balancing across nodes within a Kubernetes cluster.  Obviously this is starting small and focusing on learning.  This should evolve over time as we experiment, learn, and improve.

## The way this works...
1) Setup a Kubernetes cluster.  I used Rancher and everything is published in the Algo_Cluster_Infrastruction repo.  The one piece of the puzzle not yet captured is setting up a NFS server.  I just used a Raspberry Pi with a USB thumb drive for this purpose and shared /usb as the mount point over the network.  The only external resources I'm currently using are GitHub for my SCM and Docker Hub for my container image repository.  I also have my laptop running Ubuntu MATE 18.04 as my development environment with MS Code, OpenJDK, Gradle, Docker, and Kubectl installed locally.  This is really nice because I can build and test my code/images locally before committing them to master (and possibly breaking others).
2) Build the scenarios.  Do this from the Algo_Dev_Scenario_X repository by running "gradle dockerBuild".  This creates the based and data images in your local docker image repository.  Currently these images are treated as intermediary images and not published publically by the Gradle build.  If I wanted to reduce the coupling between my repos I could refactor these to be independent of each other.  Maybe I'll add that to the backlog for later.
3) Build and run the algorithm using both scenarios.  The commands I use are captured in the Jenkinsfile, but I have not yet actually tried to configure and test a Jenkins pipeline to automate everything.  This sequence of commands delegates to gradle to do a fresh build of everything and then to kubectl to setup the cluster environment, deploy the containerized algorithm as task pods, and then cleans up the pods afterward.  One nice aspect of the current configuration is that it demonstrates pods being distributed across nodes in the cluster for concurrent execution.  The output from each run is persisted on the NFS mount across runs.
4) Right now this just provides raw data output on the NFS mount for further investigation and analysis.  A potentially useful improvement would be adding a "quick look" analysis service (containerized and deployed to the cluster of course) that pulls data from each run and generates a nice UI for developers and testers.  Maybe I'll add that to the backlog for later.

## The Algorithm - Line Runner
We need a representative algorithm to support the proof of concept.  We're going to use a basic physics calculation for this purpose.  The algorithm will start at origin and accelerate/decellerate along a 1-dimensional path.  Scenarios are defined in separate projects (to support pipelining and container layering) and contain time ordered acceleration inputs in a CSV file.  The algorithm applies the acceleration to the current state and calculates position and velocity to establish a new state for each time step.  This algorithm utilizes instantaneous calculations, not accounting for ramping or other factors.


